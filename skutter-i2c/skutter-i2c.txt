Skutter: Expanding your senses with I2CLimitations of the GPIO on the Raspberry PiWe all love the Raspberry Pi. For me the best thing about it (apart from its low cost and low power consumption) is the General Purpose Input (and) Output header (GPIO). Having that sort of access between the virtual and real world on such a tiny yet powerful computer has allowed me to begin working on a robotics project which until recently I was only able to imagine.In spite of this, the Raspberry Pi does have some limitations when it comes to building robots. The GPIO has only a limited number of pins to work with. Let's say you have built two simple H bridge circuits to control motors on your robot. That might take up as much as eight of your GPIOs. Let’s imagine you want to include some micro switches on the gripper of a robot arm and some more switches on our robot's bumper (or fender if you are in the US) to detect collisions... before long we've got more inputs and outputs than we've got pins and things are only complicated further when we consider that if we draw more than 48mA from the whole of the GPIO at any point we run the risk of frying the whole thing!Introducing I2CSo what is a robot builder to do? Happily there is a solution to all of this. Something that throws open the doors to a whole galaxy of wonderful electronic devices and sensors. This solution is called the I2C bus (often called the “two wire interface”)   Some people pronounce this as “eye two see” whereas others say “eye squared see”, either is acceptable. One of the many available devices that use this is a “GPIO expander” such as the MCP23008. There are many others also available such as “analogue to digital converters”, “accelerometers” and many more which I will cover later.Using the I2C bus is daunting at first. I2C is unlike USB. USB just seems to work because, although highly complex, it is tightly controlled with a very rigid set of standards. The I2C bus in comparison is much more of a free-for-all. In fact, if USB is like a very disciplined, smartly turned out officer in the modern armed forces, then I2C is like a belligerent berserker from ancient Norway who has drunk too much mead and has frankly dubious standards of personal hygiene. Nevertheless he can be extremely effective.To work with this beast, first we need to understand it. It's known by the nickname “two wire” because it uses two wires to communicate between two or more devices.One of these devices is known as the master and the other devices are known as the slaves. In most conceivable situations the master would be the Raspberry Pi.A tale of two wiresOn the GPIO header are two pins called SDA and SCL. These two pins are the keys to opening the I2C bus. The first, (SDA) refers to Serial DAta and the second (SCL) refers to Serial CLock.The “SDA” is able to transmit series of bursts of eight (usually eight however some rare types use ten) ones and zeroes (or a “byte”). These bytes of data are sent along the SDA wire (bus) and are received by all of the slaves on the bus. The “clock” on the second wire is used by both the master and the slave to allow timings to coincide with these ones or zeroes. A very simplistic explanation of this; imagine if the byte sent across the SDA bus from the master was “11111110”. How would the slave know that this was seven separate “1” bits or just one single “1” bit that's been turned on for quite a long time. The clock pulses on the SCL bus allows the slave to know this.When the master sends a byte down the SDA bus, every slave on that bus will receive that byte. “Addressing” ensures that the right device actually uses it. When two devices communicate over I2C they do so in a series of bytes. This series of bytes is called a “message”. A message always begins with a special “start” sequence and ends with a special “stop” sequence. This start and stop sequence of bits cannot occur at any other time.After a start sequence, the next byte of information is a seven bit address. A byte contains eight bits and the eighth bit of the address is used to tell that slave device if it is going to be used to send or to receive data.Once the first address byte has been sent, only the device with that corresponding address continues paying attention to the rest of the message, until the stop sequence is received. All the others simply stop paying attention until the stop message sequence is sent.Disorganisation is the key to successThis seems to be reasonably logical so far. From this point in however is where we get to the disorganised part. The I2C protocol dictates what “start message” and “stop message” must be and that the first byte of the message must be the address of the slave device. After that there are no rules at all. Every different I2C device is allowed to use all the data between the address and the stop sequence in any way it wants. Before you can use an I2C device, you have to study the documentation (called the data sheet) for it to understand how it uses all those bytes of data.In the rest of this article I will provide an example of this by working through the relevant parts of the datasheet for the MCP23008 I2C GPIO expander, how to connect this to the Raspberry Pi and how to write a simple Python program to control it.An example I2C project - Controlling the MCP23008 using a Raspberry Pi.The MCP23008 is very useful to a robot builder because it gives us a relatively simple means of providing more inputs and outputs than the standard GPIO and with more power available.As stated already, every I2C device works differently. For this reason it's essential to obtain a copy of the datasheet for the device you are working with. To get the most from this article I recommend obtaining a copy of the MCP23008 datasheet (you can easily find this on the internet using your favourite search engine). From here on in I will be referring to the “MCP23008/MCP23S08 8-Bit I/O Expander with Serial Interface” published in  2007 by Microchip Technology Inc . The first useful piece of information in this datasheet is the pin out diagram on page 2. Make sure you look at the pin out for the correct device as several are shown on this page. Using this diagram we can begin to make sense of how we can connect this microchip to our Raspberry Pi. The first question is which way is “up” on our microchip? If you look carefully you will see a small notch on one end of the device. This signifies “top”.The key here is the first two pins on the left hand side, SCL and SCA. These can be connected to the corresponding pins on the GPIO of the Raspberry Pi.The next three pins along are A2, A1 and A0. A quick scan down to the pin out descriptions on page 5 reveals that these are the address pins. On page 8 the datasheet states “The slave address contains four fixed bits and three user-defined hardware address bits” This means this part of the address byte can be configured to whatever we want. Let's assume we connect the pins A2, A1 and A0 to ground. This is equivalent to making them 000. On the same page we are given a diagram that shows the first part of the address for this device must begin with 0100. Our three pins set the second part of this address to 000, therefore the address for this device configured in this way would be  0100000.The very final bit in this address is used to command the MCP23008 to work as an input or an output. The diagram on page 8 of the datasheet shows we must use 0 for write and 1 for read. The next pin along is called “reset”. The pinout description on page 5 declares this must be biased externally. For normal use you can get away with just connecting this pin directly to the +ve part of your power supply.The other two really important pins are VSS and VDD. VSS is ground and VDD is +ve power. (I found that out by checking the pin out description again on page 5 of the datasheet)Skipping along in the datasheet to page 23 we find the electrical characteristics of the device. From here we can see that this microchip can run on 3.3v logic or 5v logic. Additionally we can see that the device can sink or source 25mA from each GPIO up to a total of 125 mA.Access to this extra power boost from the GPIO is very useful. Not only does it give us more pins, it supplies more power as well! This is a great advantage when for example, building a H bridge motor controller. It means we can use much cheaper, lower valued current gain transistors than those that were necessary when running one directly from the Raspberry Pi GPIO.There is another important health warning to consider here however. Although it is possible to run this device on 3.3v or 5v, the Raspberry Pi itself is not tolerant of 5v. Connecting this device to a 5v supply and then trying to use your raspberry pi to control it is very likely to cause terminal damage to at least the GPIO, if not the whole raspberry pi! Happily it is possible to convert the 3v3 logic of the Pi to 5v logic and let the two run safely together using a simple logic level converter circuit. I will describe this circuit later on. For now I will explain how to start using the MCP23008 with the Raspberry Pi.Setting up the MCP23008 and Raspberry PiStart off by carefully plugging the MCP23008 into some breadboard. You will see a “gutter” going down the middle of your breadboard. This gutter may as well be designed specifically for microchips and serves two purposes. Firstly it isolates the two halves of the breadboard from each other. This means that you can plug in the MCP23008 and know that you are not connecting the pins on either side of the chip to each other. The second purpose of this gutter means that when you want to remove a microchip, you can carefully work a small flat headed screwdriver under the chip and along the gutter to lift the chip out without horribly bending all the pins.Before we can start using I2C on the Raspberry Pi we need to make a few changes to some configuration files (assuming you are using a Raspbian distro)Open the file /etc/modprobe.d/raspi-blacklist.conf and uncomment the two lines with:# blacklist spi-bcm2708# blacklist i2c-bcm2708Next, open the file  /etc/modules and add linessnd-bcm2835i2c-devTurn off your Raspberry!Plug in the MCP23008.Connect the SDA and SCL on the chip to the corresponding GPIO on the Raspberry Pi.Connect VDD and RESET on the chip to 3v3 power on the GPIO. Connect VDD on the chip to Ground on the Pi. We are now ready to try a few experiments. Turn on the Raspberry Pi.We are going to be using i2c-tools and Python with “smbus”. You may need to install these on your Raspberry Pi. This can be accomplished with sudo apt-get install i2c-tools and sudo apt-get install python-smbus. From the command line enter the command sudo i2cdetect -y 0 (if you have a newer revision 1 Raspberry Pi, replace 0 with 1).If everything is connected up properly you should see output something like:   0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f00:          -- -- -- -- -- -- -- -- -- -- -- -- -- 10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 20: 20 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 70: -- -- -- -- -- -- -- –This means your chip works, is ready to go and is communicating with the Pi on address (hex) 0x20.If we want to use more power than the GPIO on the Raspberry Pi can deliver there is a few more steps we need to take first.Converting 3v3 to 5v logic and vice versaConnecting VDD of the MCP23008 to 3v3 on the GPIO of the Raspberry Pi means that the output of this chip is still affected by the GPIO power limitations. We can connect the device to the 5V supply instead, however that means you are mixing 5V logic with 3V3 logic on the Raspberry Pi. The Raspberry Pi will not take kindly to this!This diagram shows a simple circuit that can safely convert 3v3 logic to 5v logic and vice versa. It uses two MOSFETs. A suitable MOSFET is the commonly available BSN20.Be warned however – it is a very small device. To get it working myself I broke the tracks on a small piece of stripboard, soldered the terminals of the MOSFET across these and then added some larger connectors to make it suitable for plugging into breadboard.The symbol used here is not the conventional MOSFET symbol. I have shown it like this to help visualise the way the little device should be connected.The purple line signifies 3v3 from the GPIO. This goes to the “gate” on the MOSFET. The red line signifies the 5V supply. This is connected to the “drain” of both of the MOSFETs via a “pull up resistor”. (In I2C the natural state of the bus is “low”. When a current is applied to the bus via a pull up resistor, it temporarily pulls the signal up to an “on” or “high” condition.)The value of the pull up resistor is not that important. It's generally agreed it should be between 1K and 10K. Many people use 4.7K and report that it works well and this is the value I used for my version of the circuit.Finally, we need to provide conversion from SCL and SDA on the Raspberry Pi. These lines should be connected to the “source” of the MOSFET.Everything on the right hand side of this circuit is now a 5V I2C bus and everything on the left is a 3V3 I2C bus and the two can work safely together in series!Creating an example Python H bridge control programWe are now ready to control the GPIO pins  0 to 7 on the device. Looking at page 6 of the datasheet we can see that the MCP23008 uses a number of internal registers to control everything the device is capable of. Sometimes the language used in data sheets can be confusing so I have tried to translate into plain English the name, address and function of each register and put it in the table below. I recommend reading the datasheet first and then checking your understanding as being able to read these documents is an important skill.RegisterAddress (Hex)DescriptionIODIR0x000 = out, 1 = inIPOL0x01input/output polarity on gpio. bit 7 to bit 0. If bit set, gpio value will reflect the inverted valueGPINTEN0x02interrupt on change. bit 7 to bit0. If bit is set then will generate an interrupt if that pin changes.DEFVAL0x03default value to compare against GPINTEN. bit 7 to bit0. If bit is set, opposite value on corresponding pin will generate interruptINTCON0x04interrupt control register. If bit is set then corresponding IO pin will be compared against that set in DEFVAL registerIOCON0x05 setup / config. bit 5 = sequential operation. bit 4 slew rate. bit 3 not used. bit 2 open drain. bit 1 interrupt polarity sets polarity of INT pin. Only functions if open drain bit is clearGPPU0x06gppu pull up resistor, bit 7 to bit 0. if bit set, if bit set and pin is input then this will pull up the pin with 100k resistorINTF0x07interrupt flag register. bit7 to bit 0. bit set means the associated pin will generate an interrupt. A set bit in this register tells us which pin caused the interrupt. READ ONLY.INTCAP0x08interrupt capture. Captures GPIO value at time of interrupt. bit 7 to bit 0. Remains unchanged until interrupt cleared via a read of INTCAP or GPIOGPIO0x09the GPIO. bit7 to bit 0OLAT0x0Aoutput latchesThe only registers we are really interested in are IODIR and GPIO. Nevertheless it is important to set all the other registers as well to try to prevent anything unexpected happening.The last Skutter article included some simple Python code to control a H bridge connected to the GPIO on the Raspberry Pi.This is code that would control two H bridges connected to the GPIO's on an MCP23008. (Don’t forget to change to bus 1 if you are using a revision 2 Raspberry Pi)I hope this will help you to begin to understand how to control I2C devices and how useful they can be to a robot builder. If you find a device that can perform a vital function for a robot you are building (such as an analogue to digital converter, an accelerometer or a distance sensor), hopefully you will now be able to read through the datasheet and make sense of how to control it.#! /usr/bin/pythonimport smbus import time address = 0x20 #define all the registersIODIR=0x00 IPOL=0x01 GPINTEN=0x02DEFVAL=0x03 INTCON=0x04   IOCON=0x05 GPPU=0x06INTF=0x07INTCAP=0x08GPIO=0x09OLAT=0x0Abus = smbus.SMBus(0)#set IODIR as OUTPUTbus.write_byte_data(address, IODIR, 0b00000000)#reset all the other registersfor reg in [IPOL, GPINTEN, DEFVAL, INTCON, IOCON, GPU, INTF, INTCAP, GPIO, OLAT]:	bus.write_byte_data(address, reg, 0b00000000)#Set the GPIO's to turn on / off transistors in H bridge. See associated circuit diagram.#GPIO 0 - 1 = motor 1 fwd.#GPIO 1 - 1 = motor 1 fwd.#GPIO 2 - 1 = motor 1 rev.#GPIO 3 - 1 = motor 1 rev.#GPIO 4 - 1 = motor 2 fwd#GPIO 5 - 1 = motor 2 fwd#GPIO 6 - 1 = motor 2 rev#GPIO 7 - 1 = motor 2 rev#--------------------IMPORTANT---------------------#IF GPIO 0, 1 is "1" THEN GPIO 2, 3 must be "0" ELSE transistor short circuit.#IF GPIO 4, 5 is "1" THEN GPIO 6, 7 must be "0" ELSE transistor short circuit.#------------------------------------------------------------#set all GPIO offbus.write_byte_data(address, GPIO, 0b00000000))#test motor 1 and motor 2 FWD for  3 secsbus.write_byte_data(address, GPIO, 0b00000011))time.sleep(3)#set all GPIO offbus.write_byte_data(address, GPIO, 0b00000000))time.sleep(1)#test motor 1 and motor 2 REV for 3 secsbus.write_byte_data(address, GPIO, 0b00001100)time.sleep(3)#set all GPIO offbus.write_byte_data(address, GPIO, 0b00000000)time.sleep(1)#test hard right turn for 1 secbus.write_byte_data(address, GPIO, 0b11000011)time.sleep(1)#test hard left turn for 1 secbus.write_byte_data(address, GPIO, 0b00111100)time.sleep(1)#set all GPIO offbus.write_byte_data(address, GPIO, 0b00000000)      